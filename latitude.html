<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>pymap3d.latitude API documentation</title>
<meta name="description" content="geodetic transforms to auxilary coordinate systems involving latitude" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pymap3d.latitude</code></h1>
</header>
<section id="section-intro">
<p>geodetic transforms to auxilary coordinate systems involving latitude</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;geodetic transforms to auxilary coordinate systems involving latitude&#34;&#34;&#34;
from .ellipsoid import Ellipsoid
from .utils import sanitize

try:
    from numpy import radians, degrees, tan, sin, exp, pi, sqrt, inf, vectorize
    from numpy import arctan as atan, arcsinh as asinh, arctanh as atanh  # noqa: A001

    use_numpy = True
except ImportError:
    from math import atan, radians, degrees, tan, sin, asinh, atanh, exp, pi, sqrt, inf

    use_numpy = False

__all__ = [
    &#34;geodetic2isometric&#34;,
    &#34;isometric2geodetic&#34;,
    &#34;geodetic2rectifying&#34;,
    &#34;rectifying2geodetic&#34;,
    &#34;geodetic2conformal&#34;,
    &#34;conformal2geodetic&#34;,
    &#34;geodetic2parametric&#34;,
    &#34;parametric2geodetic&#34;,
    &#34;geodetic2geocentric&#34;,
    &#34;geocentric2geodetic&#34;,
    &#34;geodetic2authalic&#34;,
    &#34;authalic2geodetic&#34;,
]


def geodetic2geocentric(geodetic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    convert geodetic latitude to geocentric latitude.

    like Matlab geocentricLatitude()

    Parameters
    ----------
    geodetic_lat : float
        geodetic latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    geocentric_lat : float
         geocentric latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.
    &#34;&#34;&#34;
    geodetic_lat, ell = sanitize(geodetic_lat, ell, deg)

    geocentric_lat = atan((1 - (ell.eccentricity) ** 2) * tan(geodetic_lat))

    return degrees(geocentric_lat) if deg else geocentric_lat


def geocentric2geodetic(geocentric_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from geocentric latitude to geodetic latitude

    like Matlab geodeticLatitudeFromGeocentric()

    Parameters
    ----------
    geocentric_lat : float
         geocentric latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    geodetic_lat : float
         geodetic latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.
    &#34;&#34;&#34;
    geocentric_lat, ell = sanitize(geocentric_lat, ell, deg)

    geodetic_lat = atan(tan(geocentric_lat) / (1 - (ell.eccentricity) ** 2))

    return degrees(geodetic_lat) if deg else geodetic_lat


def geodetic2isometric_point(geodetic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    geodetic_lat, ell = sanitize(geodetic_lat, ell, deg)

    e = ell.eccentricity

    if abs(geodetic_lat - pi / 2) &lt;= 1e-9:
        isometric_lat = inf
    elif abs(-geodetic_lat - pi / 2) &lt;= 1e-9:
        isometric_lat = -inf
    else:
        isometric_lat = asinh(tan(geodetic_lat)) - e * atanh(e * sin(geodetic_lat))
        # same results
        # a1 = e * sin(geodetic_lat)
        # y = (1 - a1) / (1 + a1)
        # a2 = pi / 4 + geodetic_lat / 2
        # isometric_lat = log(tan(a2) * (y ** (e / 2)))
        # isometric_lat = log(tan(a2)) + e/2 * log((1-e*sin(geodetic_lat)) / (1+e*sin(geodetic_lat)))

    return degrees(isometric_lat) if deg else isometric_lat


def geodetic2isometric(geodetic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    computes isometric latitude on an ellipsoid


    like Matlab map.geodesy.IsometricLatitudeConverter.forward()

    Parameters
    ----------
    lat : float
         geodetic latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    isolat : float
         isometric latiude

    Notes
    -----
    Isometric latitude is an auxiliary latitude proportional to the spacing
    of parallels of latitude on an ellipsoidal mercator projection.
    Based on Deakin, R.E., 2010, &#39;The Loxodrome on an Ellipsoid&#39;, Lecture Notes,
    School of Mathematical and Geospatial Sciences, RMIT University,
    January 2010
    &#34;&#34;&#34;
    if use_numpy:
        fun = vectorize(geodetic2isometric_point)
        return fun(geodetic_lat, ell, deg)
    else:
        return geodetic2isometric_point(geodetic_lat, ell, deg)


def isometric2geodetic(isometric_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from isometric latitude to geodetic latitude

    like Matlab map.geodesy.IsometricLatitudeConverter.inverse()

    Parameters
    ----------
    isometric_lat : float
         isometric latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    geodetic_lat : float
         geodetic latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.
    &#34;&#34;&#34;
    # NOT sanitize for isometric2geo
    if deg:
        isometric_lat = radians(isometric_lat)

    conformal_lat = 2 * atan(exp(isometric_lat)) - (pi / 2)
    geodetic_lat = conformal2geodetic(conformal_lat, ell, deg=False)

    return degrees(geodetic_lat) if deg else geodetic_lat


def conformal2geodetic(conformal_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from conformal latitude to geodetic latitude

    like Matlab map.geodesy.ConformalLatitudeConverter.inverse()

    Parameters
    ----------
    conformal_lat : float
        conformal latitude
    ell : Ellipsoid, optional
        reference ellipsoid (default WGS84)
    deg : bool, optional
        degrees input/output  (False: radians in/out)

    Returns
    -------
    geodetic_lat : float
        geodetic latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.
    &#34;&#34;&#34;
    conformal_lat, ell = sanitize(conformal_lat, ell, deg)

    e = ell.eccentricity
    f1 = e ** 2 / 2 + 5 * e ** 4 / 24 + e ** 6 / 12 + 13 * e ** 8 / 360
    f2 = 7 * e ** 4 / 48 + 29 * e ** 6 / 240 + 811 * e ** 8 / 11520
    f3 = 7 * e ** 6 / 120 + 81 * e ** 8 / 1120
    f4 = 4279 * e ** 8 / 161280

    geodetic_lat = (
        conformal_lat
        + f1 * sin(2 * conformal_lat)
        + f2 * sin(4 * conformal_lat)
        + f3 * sin(6 * conformal_lat)
        + f4 * sin(8 * conformal_lat)
    )

    return degrees(geodetic_lat) if deg else geodetic_lat


def geodetic2conformal(geodetic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from geodetic latitude to conformal latitude

    like Matlab map.geodesy.ConformalLatitudeConverter.forward()

    Parameters
    ----------
    geodetic_lat : float
         geodetic latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    conformal_lat : float
         conformal latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.

    &#34;&#34;&#34;
    if use_numpy:
        fun = vectorize(geodetic2conformal_point)
        return fun(geodetic_lat, ell, deg)
    else:
        return geodetic2conformal_point(geodetic_lat, ell, deg)


def geodetic2conformal_point(geodetic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    geodetic_lat, ell = sanitize(geodetic_lat, ell, deg)

    e = ell.eccentricity
    f1 = 1 - e * sin(geodetic_lat)
    f2 = 1 + e * sin(geodetic_lat)
    f3 = 1 - sin(geodetic_lat)
    f4 = 1 + sin(geodetic_lat)

    #  compute conformal latitudes with correction for points at +90
    try:
        conformal_lat = 2 * atan(sqrt((f4 / f3) * ((f1 / f2) ** e))) - (pi / 2)
    except ZeroDivisionError:
        conformal_lat = pi / 2

    return degrees(conformal_lat) if deg else conformal_lat


# %% rectifying
def geodetic2rectifying(geodetic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from geodetic latitude to rectifying latitude

    like Matlab map.geodesy.RectifyingLatitudeConverter.forward()

    Parameters
    ----------
    geodetic_lat : float
         geodetic latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    rectifying_lat : float
         rectifying latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.

    &#34;&#34;&#34;
    geodetic_lat, ell = sanitize(geodetic_lat, ell, deg)

    n = ell.thirdflattening
    f1 = 3 * n / 2 - 9 * n ** 3 / 16
    f2 = 15 * n ** 2 / 16 - 15 * n ** 4 / 32
    f3 = 35 * n ** 3 / 48
    f4 = 315 * n ** 4 / 512

    rectifying_lat = (
        geodetic_lat
        - f1 * sin(2 * geodetic_lat)
        + f2 * sin(4 * geodetic_lat)
        - f3 * sin(6 * geodetic_lat)
        + f4 * sin(8 * geodetic_lat)
    )

    return degrees(rectifying_lat) if deg else rectifying_lat


def rectifying2geodetic(rectifying_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from rectifying latitude to geodetic latitude

    like Matlab map.geodesy.RectifyingLatitudeConverter.inverse()

    Parameters
    ----------
    rectifying_lat : float
        latitude
    ell : Ellipsoid, optional
        reference ellipsoid (default WGS84)
    deg : bool, optional
        degrees input/output  (False: radians in/out)

    Returns
    -------
    geodetic_lat : float
        geodetic latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.
    &#34;&#34;&#34;
    rectifying_lat, ell = sanitize(rectifying_lat, ell, deg)

    n = ell.thirdflattening
    f1 = 3 * n / 2 - 27 * n ** 3 / 32
    f2 = 21 * n ** 2 / 16 - 55 * n ** 4 / 32
    f3 = 151 * n ** 3 / 96
    f4 = 1097 * n ** 4 / 512

    geodetic_lat = (
        rectifying_lat
        + f1 * sin(2 * rectifying_lat)
        + f2 * sin(4 * rectifying_lat)
        + f3 * sin(6 * rectifying_lat)
        + f4 * sin(8 * rectifying_lat)
    )

    return degrees(geodetic_lat) if deg else geodetic_lat


# %% authalic
def geodetic2authalic(geodetic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from geodetic latitude to authalic latitude

    like Matlab map.geodesy.AuthalicLatitudeConverter.forward()

    Parameters
    ----------
    geodetic_lat : float
         geodetic latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    authalic_lat : float
         authalic latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.

    &#34;&#34;&#34;
    geodetic_lat, ell = sanitize(geodetic_lat, ell, deg)

    e = ell.eccentricity
    f1 = e ** 2 / 3 + 31 * e ** 4 / 180 + 59 * e ** 6 / 560
    f2 = 17 * e ** 4 / 360 + 61 * e ** 6 / 1260
    f3 = 383 * e ** 6 / 45360

    authalic_lat = geodetic_lat - f1 * sin(2 * geodetic_lat) + f2 * sin(4 * geodetic_lat) - f3 * sin(6 * geodetic_lat)

    return degrees(authalic_lat) if deg else authalic_lat


def authalic2geodetic(authalic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from authalic latitude to geodetic latitude

    like Matlab map.geodesy.AuthalicLatitudeConverter.inverse()

    Parameters
    ----------
    authalic_lat : float
        latitude
    ell : Ellipsoid, optional
        reference ellipsoid (default WGS84)
    deg : bool, optional
        degrees input/output  (False: radians in/out)

    Returns
    -------
    geodetic_lat : float
        geodetic latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.
    &#34;&#34;&#34;
    authalic_lat, ell = sanitize(authalic_lat, ell, deg)
    e = ell.eccentricity
    f1 = e ** 2 / 3 + 31 * e ** 4 / 180 + 517 * e ** 6 / 5040
    f2 = 23 * e ** 4 / 360 + 251 * e ** 6 / 3780
    f3 = 761 * e ** 6 / 45360

    geodetic_lat = authalic_lat + f1 * sin(2 * authalic_lat) + f2 * sin(4 * authalic_lat) + f3 * sin(6 * authalic_lat)

    return degrees(geodetic_lat) if deg else geodetic_lat


# %% parametric
def geodetic2parametric(geodetic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from geodetic latitude to parametric latitude

    like Matlab parametriclatitude()

    Parameters
    ----------
    geodetic_lat : float
         geodetic latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    parametric_lat : float
         parametric latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.

    &#34;&#34;&#34;
    geodetic_lat, ell = sanitize(geodetic_lat, ell, deg)

    parametric_lat = atan(sqrt(1 - (ell.eccentricity) ** 2) * tan(geodetic_lat))

    return degrees(parametric_lat) if deg else parametric_lat


def parametric2geodetic(parametric_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from parametric latitude to geodetic latitude

    like Matlab geodeticLatitudeFromParametric()

    Parameters
    ----------
    parametric_lat : float
        latitude
    ell : Ellipsoid, optional
        reference ellipsoid (default WGS84)
    deg : bool, optional
        degrees input/output  (False: radians in/out)

    Returns
    -------
    geodetic_lat : float
        geodetic latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.
    &#34;&#34;&#34;
    parametric_lat, ell = sanitize(parametric_lat, ell, deg)

    geodetic_lat = atan(tan(parametric_lat) / sqrt(1 - (ell.eccentricity) ** 2))

    return degrees(geodetic_lat) if deg else geodetic_lat</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pymap3d.latitude.authalic2geodetic"><code class="name flex">
<span>def <span class="ident">authalic2geodetic</span></span>(<span>authalic_lat, ell=None, deg=True)</span>
</code></dt>
<dd>
<section class="desc"><p>converts from authalic latitude to geodetic latitude</p>
<p>like Matlab map.geodesy.AuthalicLatitudeConverter.inverse()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>authalic_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>latitude</dd>
<dt><strong><code>ell</code></strong> :&ensp;<code>Ellipsoid</code>, optional</dt>
<dd>reference ellipsoid (default WGS84)</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>degrees input/output
(False: radians in/out)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>geodetic_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>geodetic latiude</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Equations from J. P. Snyder, "Map Projections - A Working Manual",
US Geological Survey Professional Paper 1395, US Government Printing
Office, Washington, DC, 1987, pp. 13-18.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def authalic2geodetic(authalic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from authalic latitude to geodetic latitude

    like Matlab map.geodesy.AuthalicLatitudeConverter.inverse()

    Parameters
    ----------
    authalic_lat : float
        latitude
    ell : Ellipsoid, optional
        reference ellipsoid (default WGS84)
    deg : bool, optional
        degrees input/output  (False: radians in/out)

    Returns
    -------
    geodetic_lat : float
        geodetic latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.
    &#34;&#34;&#34;
    authalic_lat, ell = sanitize(authalic_lat, ell, deg)
    e = ell.eccentricity
    f1 = e ** 2 / 3 + 31 * e ** 4 / 180 + 517 * e ** 6 / 5040
    f2 = 23 * e ** 4 / 360 + 251 * e ** 6 / 3780
    f3 = 761 * e ** 6 / 45360

    geodetic_lat = authalic_lat + f1 * sin(2 * authalic_lat) + f2 * sin(4 * authalic_lat) + f3 * sin(6 * authalic_lat)

    return degrees(geodetic_lat) if deg else geodetic_lat</code></pre>
</details>
</dd>
<dt id="pymap3d.latitude.conformal2geodetic"><code class="name flex">
<span>def <span class="ident">conformal2geodetic</span></span>(<span>conformal_lat, ell=None, deg=True)</span>
</code></dt>
<dd>
<section class="desc"><p>converts from conformal latitude to geodetic latitude</p>
<p>like Matlab map.geodesy.ConformalLatitudeConverter.inverse()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>conformal_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>conformal latitude</dd>
<dt><strong><code>ell</code></strong> :&ensp;<code>Ellipsoid</code>, optional</dt>
<dd>reference ellipsoid (default WGS84)</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>degrees input/output
(False: radians in/out)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>geodetic_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>geodetic latiude</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Equations from J. P. Snyder, "Map Projections - A Working Manual",
US Geological Survey Professional Paper 1395, US Government Printing
Office, Washington, DC, 1987, pp. 13-18.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def conformal2geodetic(conformal_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from conformal latitude to geodetic latitude

    like Matlab map.geodesy.ConformalLatitudeConverter.inverse()

    Parameters
    ----------
    conformal_lat : float
        conformal latitude
    ell : Ellipsoid, optional
        reference ellipsoid (default WGS84)
    deg : bool, optional
        degrees input/output  (False: radians in/out)

    Returns
    -------
    geodetic_lat : float
        geodetic latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.
    &#34;&#34;&#34;
    conformal_lat, ell = sanitize(conformal_lat, ell, deg)

    e = ell.eccentricity
    f1 = e ** 2 / 2 + 5 * e ** 4 / 24 + e ** 6 / 12 + 13 * e ** 8 / 360
    f2 = 7 * e ** 4 / 48 + 29 * e ** 6 / 240 + 811 * e ** 8 / 11520
    f3 = 7 * e ** 6 / 120 + 81 * e ** 8 / 1120
    f4 = 4279 * e ** 8 / 161280

    geodetic_lat = (
        conformal_lat
        + f1 * sin(2 * conformal_lat)
        + f2 * sin(4 * conformal_lat)
        + f3 * sin(6 * conformal_lat)
        + f4 * sin(8 * conformal_lat)
    )

    return degrees(geodetic_lat) if deg else geodetic_lat</code></pre>
</details>
</dd>
<dt id="pymap3d.latitude.geocentric2geodetic"><code class="name flex">
<span>def <span class="ident">geocentric2geodetic</span></span>(<span>geocentric_lat, ell=None, deg=True)</span>
</code></dt>
<dd>
<section class="desc"><p>converts from geocentric latitude to geodetic latitude</p>
<p>like Matlab geodeticLatitudeFromGeocentric()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geocentric_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>geocentric latitude</dd>
<dt><strong><code>ell</code></strong> :&ensp;<code>Ellipsoid</code>, optional</dt>
<dd>reference ellipsoid (default WGS84)</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>degrees input/output
(False: radians in/out)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>geodetic_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>geodetic latiude</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Equations from J. P. Snyder, "Map Projections - A Working Manual",
US Geological Survey Professional Paper 1395, US Government Printing
Office, Washington, DC, 1987, pp. 13-18.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def geocentric2geodetic(geocentric_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from geocentric latitude to geodetic latitude

    like Matlab geodeticLatitudeFromGeocentric()

    Parameters
    ----------
    geocentric_lat : float
         geocentric latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    geodetic_lat : float
         geodetic latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.
    &#34;&#34;&#34;
    geocentric_lat, ell = sanitize(geocentric_lat, ell, deg)

    geodetic_lat = atan(tan(geocentric_lat) / (1 - (ell.eccentricity) ** 2))

    return degrees(geodetic_lat) if deg else geodetic_lat</code></pre>
</details>
</dd>
<dt id="pymap3d.latitude.geodetic2authalic"><code class="name flex">
<span>def <span class="ident">geodetic2authalic</span></span>(<span>geodetic_lat, ell=None, deg=True)</span>
</code></dt>
<dd>
<section class="desc"><p>converts from geodetic latitude to authalic latitude</p>
<p>like Matlab map.geodesy.AuthalicLatitudeConverter.forward()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geodetic_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>geodetic latitude</dd>
<dt><strong><code>ell</code></strong> :&ensp;<code>Ellipsoid</code>, optional</dt>
<dd>reference ellipsoid (default WGS84)</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>degrees input/output
(False: radians in/out)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>authalic_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>authalic latiude</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Equations from J. P. Snyder, "Map Projections - A Working Manual",
US Geological Survey Professional Paper 1395, US Government Printing
Office, Washington, DC, 1987, pp. 13-18.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def geodetic2authalic(geodetic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from geodetic latitude to authalic latitude

    like Matlab map.geodesy.AuthalicLatitudeConverter.forward()

    Parameters
    ----------
    geodetic_lat : float
         geodetic latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    authalic_lat : float
         authalic latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.

    &#34;&#34;&#34;
    geodetic_lat, ell = sanitize(geodetic_lat, ell, deg)

    e = ell.eccentricity
    f1 = e ** 2 / 3 + 31 * e ** 4 / 180 + 59 * e ** 6 / 560
    f2 = 17 * e ** 4 / 360 + 61 * e ** 6 / 1260
    f3 = 383 * e ** 6 / 45360

    authalic_lat = geodetic_lat - f1 * sin(2 * geodetic_lat) + f2 * sin(4 * geodetic_lat) - f3 * sin(6 * geodetic_lat)

    return degrees(authalic_lat) if deg else authalic_lat</code></pre>
</details>
</dd>
<dt id="pymap3d.latitude.geodetic2conformal"><code class="name flex">
<span>def <span class="ident">geodetic2conformal</span></span>(<span>geodetic_lat, ell=None, deg=True)</span>
</code></dt>
<dd>
<section class="desc"><p>converts from geodetic latitude to conformal latitude</p>
<p>like Matlab map.geodesy.ConformalLatitudeConverter.forward()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geodetic_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>geodetic latitude</dd>
<dt><strong><code>ell</code></strong> :&ensp;<code>Ellipsoid</code>, optional</dt>
<dd>reference ellipsoid (default WGS84)</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>degrees input/output
(False: radians in/out)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>conformal_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>conformal latiude</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Equations from J. P. Snyder, "Map Projections - A Working Manual",
US Geological Survey Professional Paper 1395, US Government Printing
Office, Washington, DC, 1987, pp. 13-18.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def geodetic2conformal(geodetic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from geodetic latitude to conformal latitude

    like Matlab map.geodesy.ConformalLatitudeConverter.forward()

    Parameters
    ----------
    geodetic_lat : float
         geodetic latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    conformal_lat : float
         conformal latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.

    &#34;&#34;&#34;
    if use_numpy:
        fun = vectorize(geodetic2conformal_point)
        return fun(geodetic_lat, ell, deg)
    else:
        return geodetic2conformal_point(geodetic_lat, ell, deg)</code></pre>
</details>
</dd>
<dt id="pymap3d.latitude.geodetic2geocentric"><code class="name flex">
<span>def <span class="ident">geodetic2geocentric</span></span>(<span>geodetic_lat, ell=None, deg=True)</span>
</code></dt>
<dd>
<section class="desc"><p>convert geodetic latitude to geocentric latitude.</p>
<p>like Matlab geocentricLatitude()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geodetic_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>geodetic latitude</dd>
<dt><strong><code>ell</code></strong> :&ensp;<code>Ellipsoid</code>, optional</dt>
<dd>reference ellipsoid (default WGS84)</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>degrees input/output
(False: radians in/out)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>geocentric_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>geocentric latiude</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Equations from J. P. Snyder, "Map Projections - A Working Manual",
US Geological Survey Professional Paper 1395, US Government Printing
Office, Washington, DC, 1987, pp. 13-18.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def geodetic2geocentric(geodetic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    convert geodetic latitude to geocentric latitude.

    like Matlab geocentricLatitude()

    Parameters
    ----------
    geodetic_lat : float
        geodetic latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    geocentric_lat : float
         geocentric latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.
    &#34;&#34;&#34;
    geodetic_lat, ell = sanitize(geodetic_lat, ell, deg)

    geocentric_lat = atan((1 - (ell.eccentricity) ** 2) * tan(geodetic_lat))

    return degrees(geocentric_lat) if deg else geocentric_lat</code></pre>
</details>
</dd>
<dt id="pymap3d.latitude.geodetic2isometric"><code class="name flex">
<span>def <span class="ident">geodetic2isometric</span></span>(<span>geodetic_lat, ell=None, deg=True)</span>
</code></dt>
<dd>
<section class="desc"><p>computes isometric latitude on an ellipsoid</p>
<p>like Matlab map.geodesy.IsometricLatitudeConverter.forward()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lat</code></strong> :&ensp;<code>float</code></dt>
<dd>geodetic latitude</dd>
<dt><strong><code>ell</code></strong> :&ensp;<code>Ellipsoid</code>, optional</dt>
<dd>reference ellipsoid (default WGS84)</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>degrees input/output
(False: radians in/out)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>isolat</code></strong> :&ensp;<code>float</code></dt>
<dd>isometric latiude</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Isometric latitude is an auxiliary latitude proportional to the spacing
of parallels of latitude on an ellipsoidal mercator projection.
Based on Deakin, R.E., 2010, 'The Loxodrome on an Ellipsoid', Lecture Notes,
School of Mathematical and Geospatial Sciences, RMIT University,
January 2010</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def geodetic2isometric(geodetic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    computes isometric latitude on an ellipsoid


    like Matlab map.geodesy.IsometricLatitudeConverter.forward()

    Parameters
    ----------
    lat : float
         geodetic latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    isolat : float
         isometric latiude

    Notes
    -----
    Isometric latitude is an auxiliary latitude proportional to the spacing
    of parallels of latitude on an ellipsoidal mercator projection.
    Based on Deakin, R.E., 2010, &#39;The Loxodrome on an Ellipsoid&#39;, Lecture Notes,
    School of Mathematical and Geospatial Sciences, RMIT University,
    January 2010
    &#34;&#34;&#34;
    if use_numpy:
        fun = vectorize(geodetic2isometric_point)
        return fun(geodetic_lat, ell, deg)
    else:
        return geodetic2isometric_point(geodetic_lat, ell, deg)</code></pre>
</details>
</dd>
<dt id="pymap3d.latitude.geodetic2parametric"><code class="name flex">
<span>def <span class="ident">geodetic2parametric</span></span>(<span>geodetic_lat, ell=None, deg=True)</span>
</code></dt>
<dd>
<section class="desc"><p>converts from geodetic latitude to parametric latitude</p>
<p>like Matlab parametriclatitude()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geodetic_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>geodetic latitude</dd>
<dt><strong><code>ell</code></strong> :&ensp;<code>Ellipsoid</code>, optional</dt>
<dd>reference ellipsoid (default WGS84)</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>degrees input/output
(False: radians in/out)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>parametric_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>parametric latiude</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Equations from J. P. Snyder, "Map Projections - A Working Manual",
US Geological Survey Professional Paper 1395, US Government Printing
Office, Washington, DC, 1987, pp. 13-18.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def geodetic2parametric(geodetic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from geodetic latitude to parametric latitude

    like Matlab parametriclatitude()

    Parameters
    ----------
    geodetic_lat : float
         geodetic latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    parametric_lat : float
         parametric latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.

    &#34;&#34;&#34;
    geodetic_lat, ell = sanitize(geodetic_lat, ell, deg)

    parametric_lat = atan(sqrt(1 - (ell.eccentricity) ** 2) * tan(geodetic_lat))

    return degrees(parametric_lat) if deg else parametric_lat</code></pre>
</details>
</dd>
<dt id="pymap3d.latitude.geodetic2rectifying"><code class="name flex">
<span>def <span class="ident">geodetic2rectifying</span></span>(<span>geodetic_lat, ell=None, deg=True)</span>
</code></dt>
<dd>
<section class="desc"><p>converts from geodetic latitude to rectifying latitude</p>
<p>like Matlab map.geodesy.RectifyingLatitudeConverter.forward()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geodetic_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>geodetic latitude</dd>
<dt><strong><code>ell</code></strong> :&ensp;<code>Ellipsoid</code>, optional</dt>
<dd>reference ellipsoid (default WGS84)</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>degrees input/output
(False: radians in/out)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rectifying_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>rectifying latiude</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Equations from J. P. Snyder, "Map Projections - A Working Manual",
US Geological Survey Professional Paper 1395, US Government Printing
Office, Washington, DC, 1987, pp. 13-18.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def geodetic2rectifying(geodetic_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from geodetic latitude to rectifying latitude

    like Matlab map.geodesy.RectifyingLatitudeConverter.forward()

    Parameters
    ----------
    geodetic_lat : float
         geodetic latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    rectifying_lat : float
         rectifying latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.

    &#34;&#34;&#34;
    geodetic_lat, ell = sanitize(geodetic_lat, ell, deg)

    n = ell.thirdflattening
    f1 = 3 * n / 2 - 9 * n ** 3 / 16
    f2 = 15 * n ** 2 / 16 - 15 * n ** 4 / 32
    f3 = 35 * n ** 3 / 48
    f4 = 315 * n ** 4 / 512

    rectifying_lat = (
        geodetic_lat
        - f1 * sin(2 * geodetic_lat)
        + f2 * sin(4 * geodetic_lat)
        - f3 * sin(6 * geodetic_lat)
        + f4 * sin(8 * geodetic_lat)
    )

    return degrees(rectifying_lat) if deg else rectifying_lat</code></pre>
</details>
</dd>
<dt id="pymap3d.latitude.isometric2geodetic"><code class="name flex">
<span>def <span class="ident">isometric2geodetic</span></span>(<span>isometric_lat, ell=None, deg=True)</span>
</code></dt>
<dd>
<section class="desc"><p>converts from isometric latitude to geodetic latitude</p>
<p>like Matlab map.geodesy.IsometricLatitudeConverter.inverse()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>isometric_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>isometric latitude</dd>
<dt><strong><code>ell</code></strong> :&ensp;<code>Ellipsoid</code>, optional</dt>
<dd>reference ellipsoid (default WGS84)</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>degrees input/output
(False: radians in/out)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>geodetic_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>geodetic latiude</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Equations from J. P. Snyder, "Map Projections - A Working Manual",
US Geological Survey Professional Paper 1395, US Government Printing
Office, Washington, DC, 1987, pp. 13-18.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def isometric2geodetic(isometric_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from isometric latitude to geodetic latitude

    like Matlab map.geodesy.IsometricLatitudeConverter.inverse()

    Parameters
    ----------
    isometric_lat : float
         isometric latitude
    ell : Ellipsoid, optional
         reference ellipsoid (default WGS84)
    deg : bool, optional
         degrees input/output  (False: radians in/out)

    Returns
    -------
    geodetic_lat : float
         geodetic latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.
    &#34;&#34;&#34;
    # NOT sanitize for isometric2geo
    if deg:
        isometric_lat = radians(isometric_lat)

    conformal_lat = 2 * atan(exp(isometric_lat)) - (pi / 2)
    geodetic_lat = conformal2geodetic(conformal_lat, ell, deg=False)

    return degrees(geodetic_lat) if deg else geodetic_lat</code></pre>
</details>
</dd>
<dt id="pymap3d.latitude.parametric2geodetic"><code class="name flex">
<span>def <span class="ident">parametric2geodetic</span></span>(<span>parametric_lat, ell=None, deg=True)</span>
</code></dt>
<dd>
<section class="desc"><p>converts from parametric latitude to geodetic latitude</p>
<p>like Matlab geodeticLatitudeFromParametric()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parametric_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>latitude</dd>
<dt><strong><code>ell</code></strong> :&ensp;<code>Ellipsoid</code>, optional</dt>
<dd>reference ellipsoid (default WGS84)</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>degrees input/output
(False: radians in/out)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>geodetic_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>geodetic latiude</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Equations from J. P. Snyder, "Map Projections - A Working Manual",
US Geological Survey Professional Paper 1395, US Government Printing
Office, Washington, DC, 1987, pp. 13-18.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def parametric2geodetic(parametric_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from parametric latitude to geodetic latitude

    like Matlab geodeticLatitudeFromParametric()

    Parameters
    ----------
    parametric_lat : float
        latitude
    ell : Ellipsoid, optional
        reference ellipsoid (default WGS84)
    deg : bool, optional
        degrees input/output  (False: radians in/out)

    Returns
    -------
    geodetic_lat : float
        geodetic latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.
    &#34;&#34;&#34;
    parametric_lat, ell = sanitize(parametric_lat, ell, deg)

    geodetic_lat = atan(tan(parametric_lat) / sqrt(1 - (ell.eccentricity) ** 2))

    return degrees(geodetic_lat) if deg else geodetic_lat</code></pre>
</details>
</dd>
<dt id="pymap3d.latitude.rectifying2geodetic"><code class="name flex">
<span>def <span class="ident">rectifying2geodetic</span></span>(<span>rectifying_lat, ell=None, deg=True)</span>
</code></dt>
<dd>
<section class="desc"><p>converts from rectifying latitude to geodetic latitude</p>
<p>like Matlab map.geodesy.RectifyingLatitudeConverter.inverse()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rectifying_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>latitude</dd>
<dt><strong><code>ell</code></strong> :&ensp;<code>Ellipsoid</code>, optional</dt>
<dd>reference ellipsoid (default WGS84)</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>degrees input/output
(False: radians in/out)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>geodetic_lat</code></strong> :&ensp;<code>float</code></dt>
<dd>geodetic latiude</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Equations from J. P. Snyder, "Map Projections - A Working Manual",
US Geological Survey Professional Paper 1395, US Government Printing
Office, Washington, DC, 1987, pp. 13-18.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rectifying2geodetic(rectifying_lat: float, ell: Ellipsoid = None, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    converts from rectifying latitude to geodetic latitude

    like Matlab map.geodesy.RectifyingLatitudeConverter.inverse()

    Parameters
    ----------
    rectifying_lat : float
        latitude
    ell : Ellipsoid, optional
        reference ellipsoid (default WGS84)
    deg : bool, optional
        degrees input/output  (False: radians in/out)

    Returns
    -------
    geodetic_lat : float
        geodetic latiude

    Notes
    -----
    Equations from J. P. Snyder, &#34;Map Projections - A Working Manual&#34;,
    US Geological Survey Professional Paper 1395, US Government Printing
    Office, Washington, DC, 1987, pp. 13-18.
    &#34;&#34;&#34;
    rectifying_lat, ell = sanitize(rectifying_lat, ell, deg)

    n = ell.thirdflattening
    f1 = 3 * n / 2 - 27 * n ** 3 / 32
    f2 = 21 * n ** 2 / 16 - 55 * n ** 4 / 32
    f3 = 151 * n ** 3 / 96
    f4 = 1097 * n ** 4 / 512

    geodetic_lat = (
        rectifying_lat
        + f1 * sin(2 * rectifying_lat)
        + f2 * sin(4 * rectifying_lat)
        + f3 * sin(6 * rectifying_lat)
        + f4 * sin(8 * rectifying_lat)
    )

    return degrees(geodetic_lat) if deg else geodetic_lat</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pymap3d" href="index.html">pymap3d</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pymap3d.latitude.authalic2geodetic" href="#pymap3d.latitude.authalic2geodetic">authalic2geodetic</a></code></li>
<li><code><a title="pymap3d.latitude.conformal2geodetic" href="#pymap3d.latitude.conformal2geodetic">conformal2geodetic</a></code></li>
<li><code><a title="pymap3d.latitude.geocentric2geodetic" href="#pymap3d.latitude.geocentric2geodetic">geocentric2geodetic</a></code></li>
<li><code><a title="pymap3d.latitude.geodetic2authalic" href="#pymap3d.latitude.geodetic2authalic">geodetic2authalic</a></code></li>
<li><code><a title="pymap3d.latitude.geodetic2conformal" href="#pymap3d.latitude.geodetic2conformal">geodetic2conformal</a></code></li>
<li><code><a title="pymap3d.latitude.geodetic2geocentric" href="#pymap3d.latitude.geodetic2geocentric">geodetic2geocentric</a></code></li>
<li><code><a title="pymap3d.latitude.geodetic2isometric" href="#pymap3d.latitude.geodetic2isometric">geodetic2isometric</a></code></li>
<li><code><a title="pymap3d.latitude.geodetic2parametric" href="#pymap3d.latitude.geodetic2parametric">geodetic2parametric</a></code></li>
<li><code><a title="pymap3d.latitude.geodetic2rectifying" href="#pymap3d.latitude.geodetic2rectifying">geodetic2rectifying</a></code></li>
<li><code><a title="pymap3d.latitude.isometric2geodetic" href="#pymap3d.latitude.isometric2geodetic">isometric2geodetic</a></code></li>
<li><code><a title="pymap3d.latitude.parametric2geodetic" href="#pymap3d.latitude.parametric2geodetic">parametric2geodetic</a></code></li>
<li><code><a title="pymap3d.latitude.rectifying2geodetic" href="#pymap3d.latitude.rectifying2geodetic">rectifying2geodetic</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>