<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.3" />
<title>pymap3d.haversine API documentation</title>
<meta name="description" content="Michael Hirsch â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>pymap3d.haversine</code> module</h1>
</header>
<section id="section-intro">
<p>Michael Hirsch</p>
<p>Note:
decimal points on constants made 0 difference in <code>%timeit</code> execution time</p>
<p>The Meeus algorithm is about 9.5% faster than Astropy/Vicenty on my PC,
and gives virtually identical result
within double precision arithmetic limitations</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># Copyright (c) 2014-2018 Michael Hirsch, Ph.D.
&#34;&#34;&#34;
Michael Hirsch

Note:
decimal points on constants made 0 difference in `%timeit` execution time

The Meeus algorithm is about 9.5% faster than Astropy/Vicenty on my PC,
and gives virtually identical result
within double precision arithmetic limitations
&#34;&#34;&#34;

try:
    from numpy import cos, arcsin, sqrt, radians, degrees
except ImportError:
    from math import cos, sqrt, radians, degrees
    from math import asin as arcsin
try:
    from astropy.coordinates.angle_utilities import angular_separation
except ImportError:
    angular_separation = None

__all__ = [&#39;anglesep&#39;, &#39;anglesep_meeus&#39;, &#39;haversine&#39;]


def anglesep_meeus(lon0: float, lat0: float,
                   lon1: float, lat1: float, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    Parameters
    ----------

    lon0 : float or numpy.ndarray of float
        longitude of first point
    lat0 : float or numpy.ndarray of float
        latitude of first point
    lon1 : float or numpy.ndarray of float
        longitude of second point
    lat1 : float or numpy.ndarray of float
        latitude of second point
    deg : bool, optional
          degrees input/output  (False: radians in/out)

    Returns
    -------

    sep_rad : float or numpy.ndarray of float
        angular separation


    Meeus p. 109

    from &#34;Astronomical Algorithms&#34; by Jean Meeus Ch. 16 p. 111 (16.5)
    gives angular distance in degrees between two rightAscension,Declination
    points in the sky.  Neglecting atmospheric effects, of course.

    Meeus haversine method is stable all the way to exactly 0 deg.

    either the arrays must be the same size, or one of them must be a scalar
    &#34;&#34;&#34;

    if deg:
        lon0 = radians(lon0)
        lat0 = radians(lat0)
        lon1 = radians(lon1)
        lat1 = radians(lat1)

    sep_rad = 2 * arcsin(sqrt(haversine(lat0 - lat1) +
                              cos(lat0) * cos(lat1) * haversine(lon0 - lon1)))

    if deg:
        return degrees(sep_rad)
    else:
        return sep_rad


def anglesep(lon0: float, lat0: float,
             lon1: float, lat1: float, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    Parameters
    ----------

    lon0 : float
        longitude of first point
    lat0 : float
        latitude of first point
    lon1 : float
        longitude of second point
    lat1 : float
        latitude of second point
    deg : bool, optional
          degrees input/output  (False: radians in/out)

    Returns
    -------

    sep_rad : float or numpy.ndarray of float
        angular separation

    For reference, this is from astropy astropy/coordinates/angle_utilities.py
    Angular separation between two points on a sphere.
    &#34;&#34;&#34;
    if angular_separation is None:
        raise ImportError(&#39;angledist requires AstroPy. Try angledis_meeus&#39;)

    if deg:
        lon0 = radians(lon0)
        lat0 = radians(lat0)
        lon1 = radians(lon1)
        lat1 = radians(lat1)

    sep_rad = angular_separation(lon0, lat0, lon1, lat1)

    if deg:
        return degrees(sep_rad)
    else:
        return sep_rad


def haversine(theta: float) -&gt; float:
    &#34;&#34;&#34;
    Compute haversine

    Parameters
    ----------

    theta : float
        angle (radians)

    Results
    -------

    htheta : float
        haversine of `theta`

    https://en.wikipedia.org/wiki/Haversine
    Meeus p. 111
    &#34;&#34;&#34;
    return (1 - cos(theta)) / 2.</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pymap3d.haversine.anglesep"><code class="name flex">
<span>def <span class="ident">anglesep</span></span>(<span>lon0, lat0, lon1, lat1, deg=True)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lon0</code></strong> :&ensp;<code>float</code></dt>
<dd>longitude of first point</dd>
<dt><strong><code>lat0</code></strong> :&ensp;<code>float</code></dt>
<dd>latitude of first point</dd>
<dt><strong><code>lon1</code></strong> :&ensp;<code>float</code></dt>
<dd>longitude of second point</dd>
<dt><strong><code>lat1</code></strong> :&ensp;<code>float</code></dt>
<dd>latitude of second point</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>degrees input/output
(False: radians in/out)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sep_rad</code></strong> :&ensp;<code>float</code> or <code>numpy.ndarray</code> of <code>float</code></dt>
<dd>angular separation</dd>
</dl>
<p>For reference, this is from astropy astropy/coordinates/angle_utilities.py
Angular separation between two points on a sphere.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def anglesep(lon0: float, lat0: float,
             lon1: float, lat1: float, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    Parameters
    ----------

    lon0 : float
        longitude of first point
    lat0 : float
        latitude of first point
    lon1 : float
        longitude of second point
    lat1 : float
        latitude of second point
    deg : bool, optional
          degrees input/output  (False: radians in/out)

    Returns
    -------

    sep_rad : float or numpy.ndarray of float
        angular separation

    For reference, this is from astropy astropy/coordinates/angle_utilities.py
    Angular separation between two points on a sphere.
    &#34;&#34;&#34;
    if angular_separation is None:
        raise ImportError(&#39;angledist requires AstroPy. Try angledis_meeus&#39;)

    if deg:
        lon0 = radians(lon0)
        lat0 = radians(lat0)
        lon1 = radians(lon1)
        lat1 = radians(lat1)

    sep_rad = angular_separation(lon0, lat0, lon1, lat1)

    if deg:
        return degrees(sep_rad)
    else:
        return sep_rad</code></pre>
</details>
</dd>
<dt id="pymap3d.haversine.anglesep_meeus"><code class="name flex">
<span>def <span class="ident">anglesep_meeus</span></span>(<span>lon0, lat0, lon1, lat1, deg=True)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lon0</code></strong> :&ensp;<code>float</code> or <code>numpy.ndarray</code> of <code>float</code></dt>
<dd>longitude of first point</dd>
<dt><strong><code>lat0</code></strong> :&ensp;<code>float</code> or <code>numpy.ndarray</code> of <code>float</code></dt>
<dd>latitude of first point</dd>
<dt><strong><code>lon1</code></strong> :&ensp;<code>float</code> or <code>numpy.ndarray</code> of <code>float</code></dt>
<dd>longitude of second point</dd>
<dt><strong><code>lat1</code></strong> :&ensp;<code>float</code> or <code>numpy.ndarray</code> of <code>float</code></dt>
<dd>latitude of second point</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>degrees input/output
(False: radians in/out)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sep_rad</code></strong> :&ensp;<code>float</code> or <code>numpy.ndarray</code> of <code>float</code></dt>
<dd>angular separation</dd>
</dl>
<p>Meeus p. 109</p>
<p>from "Astronomical Algorithms" by Jean Meeus Ch. 16 p. 111 (16.5)
gives angular distance in degrees between two rightAscension,Declination
points in the sky.
Neglecting atmospheric effects, of course.</p>
<p>Meeus haversine method is stable all the way to exactly 0 deg.</p>
<p>either the arrays must be the same size, or one of them must be a scalar</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def anglesep_meeus(lon0: float, lat0: float,
                   lon1: float, lat1: float, deg: bool = True) -&gt; float:
    &#34;&#34;&#34;
    Parameters
    ----------

    lon0 : float or numpy.ndarray of float
        longitude of first point
    lat0 : float or numpy.ndarray of float
        latitude of first point
    lon1 : float or numpy.ndarray of float
        longitude of second point
    lat1 : float or numpy.ndarray of float
        latitude of second point
    deg : bool, optional
          degrees input/output  (False: radians in/out)

    Returns
    -------

    sep_rad : float or numpy.ndarray of float
        angular separation


    Meeus p. 109

    from &#34;Astronomical Algorithms&#34; by Jean Meeus Ch. 16 p. 111 (16.5)
    gives angular distance in degrees between two rightAscension,Declination
    points in the sky.  Neglecting atmospheric effects, of course.

    Meeus haversine method is stable all the way to exactly 0 deg.

    either the arrays must be the same size, or one of them must be a scalar
    &#34;&#34;&#34;

    if deg:
        lon0 = radians(lon0)
        lat0 = radians(lat0)
        lon1 = radians(lon1)
        lat1 = radians(lat1)

    sep_rad = 2 * arcsin(sqrt(haversine(lat0 - lat1) +
                              cos(lat0) * cos(lat1) * haversine(lon0 - lon1)))

    if deg:
        return degrees(sep_rad)
    else:
        return sep_rad</code></pre>
</details>
</dd>
<dt id="pymap3d.haversine.haversine"><code class="name flex">
<span>def <span class="ident">haversine</span></span>(<span>theta)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute haversine</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>angle (radians)</dd>
</dl>
<h2 id="results">Results</h2>
<dl>
<dt><strong><code>htheta</code></strong> :&ensp;<code>float</code></dt>
<dd>haversine of <code>theta</code></dd>
</dl>
<p><a href="https://en.wikipedia.org/wiki/Haversine">https://en.wikipedia.org/wiki/Haversine</a>
Meeus p. 111</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def haversine(theta: float) -&gt; float:
    &#34;&#34;&#34;
    Compute haversine

    Parameters
    ----------

    theta : float
        angle (radians)

    Results
    -------

    htheta : float
        haversine of `theta`

    https://en.wikipedia.org/wiki/Haversine
    Meeus p. 111
    &#34;&#34;&#34;
    return (1 - cos(theta)) / 2.</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pymap3d" href="index.html">pymap3d</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pymap3d.haversine.anglesep" href="#pymap3d.haversine.anglesep">anglesep</a></code></li>
<li><code><a title="pymap3d.haversine.anglesep_meeus" href="#pymap3d.haversine.anglesep_meeus">anglesep_meeus</a></code></li>
<li><code><a title="pymap3d.haversine.haversine" href="#pymap3d.haversine.haversine">haversine</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>